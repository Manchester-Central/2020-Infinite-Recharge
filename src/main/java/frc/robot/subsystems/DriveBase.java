// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.smartdashboard.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.PWMVictorSPX;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveBase extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Victor left1;
    private Victor left2;
    private Victor left3;
    private WPI_TalonSRX left4;
    private SpeedControllerGroup leftDrive;
    private Victor right1;
    private Victor right2;
    private Victor right3;
    private WPI_TalonSRX right4;
    private SpeedControllerGroup rightDrive;
    public DifferentialDrive differentialDrive1;
    private PIDController PIDRight;
    private PIDController PIDLeft;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public DriveBase() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        
        PIDRight = new PIDController(0.5, 0, 0);
        PIDLeft = new PIDController(0.5, 0, 0);

        left1 = new Victor(0);
        addChild("Left1", left1);
        left1.setInverted(false);

        left2 = new Victor(1);
        addChild("Left2", left2);
        left2.setInverted(false);

        left3 = new Victor(2);
        addChild("Left3", left3);
        left3.setInverted(false);

        left4 = new WPI_TalonSRX(4);
        addChild("Left4", left4);
        left4.setInverted(false);

        leftDrive = new SpeedControllerGroup(left1, left2, left3, left4);
        addChild("LeftDrive", leftDrive);

        right1 = new Victor(3);
        addChild("Right1", right1);
        right1.setInverted(false);

        right2 = new Victor(4);
        addChild("Right2", right2);
        right2.setInverted(false);

        right3 = new Victor(5);
        addChild("Right3", right3);
        right3.setInverted(false);

        right4 = new WPI_TalonSRX(3);
        addChild("Right4", right4);
        right4.setInverted(false);

        rightDrive = new SpeedControllerGroup(right1, right2, right3, right4);
        addChild("RightDrive", rightDrive);

        differentialDrive1 = new DifferentialDrive(leftDrive, rightDrive);
        addChild("Differential Drive 1", differentialDrive1);
        differentialDrive1.setSafetyEnabled(true);
        differentialDrive1.setExpiration(0.1);
        differentialDrive1.setMaxOutput(1.0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    private double encoderInches(WPI_TalonSRX driveInput) {
        double wheelDiameter = 4;
        double gearRatio = (double) 1 / 1; // ratio of the axel the wheel lies on to the axel the encoder reads
        int ticksPerRev = 4096; // amount of ticks in one revolution of the encoder axel
        return gearRatio * (wheelDiameter * Math.PI)
                * (driveInput.getSensorCollection().getQuadraturePosition() / ticksPerRev);
    }

    public void reportPosition() {
        double rightInches = encoderInches(right4);
        double leftInches = encoderInches(left4);
        // converts raw encoder readout to inches
        SmartDashboard.putNumber("Right Position", rightInches);
        SmartDashboard.putNumber("Left Position", leftInches);
    }

    public double getLeftPosition() {
        return -encoderInches(left4);

}
    public double getRightPosition() {
        return encoderInches(right4);
    }
    public void PIDDrive() {
        double right = PIDRight.calculate(getRightPosition());
        double left = PIDLeft.calculate(getLeftPosition());
        differentialDrive1.tankDrive(left, right);
    }
    public void setTarget(double left, double right){
        PIDLeft.setSetpoint(left);
        PIDRight.setSetpoint(right);
    }
    @Override
    public void initDefaultCommand() {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        setDefaultCommand(new TankDrive());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}
