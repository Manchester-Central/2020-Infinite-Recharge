// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.revrobotics.CANSparkMax;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.*;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Victor;
import frc.robot.commands.*;
import frc.robot.Robot;
import frc.robot.RobotConstants2019;
import frc.robot.RobotConstants2020;
import frc.robot.RobotConstantsRaft;

/**
 *
 */
public class DriveBase extends Subsystem {

    private Victor left1;
    private Victor left2;
    private Victor left3;
    private WPI_TalonSRX left4 = null;
    private SpeedControllerGroup leftDrive;
    private Victor right1;
    private Victor right2;
    private Victor right3;
    private WPI_TalonSRX right4 = null;
    private SpeedControllerGroup rightDrive;
    public DifferentialDrive differentialDrive1;
    private PIDController PIDRight;
    private PIDController PIDLeft;
    private CANSparkMax leftSpark1;
    private CANSparkMax leftSpark2;
    private CANSparkMax rightSpark1;
    private CANSparkMax rightSpark2;
    private Robot.RobotType type;
    private Encoder sim_encoder_l;
    private Encoder sim_encoder_r;
    private double setpointLeft, setpointRight;

    public DriveBase(Robot.RobotType robotType) {
        type = robotType;
        
        PIDRight = new PIDController(0.1, 0.01, 0.01);
        PIDLeft = new PIDController(0.1, 0.01, 0.01);

        if (type == Robot.RobotType.raft) {
            setupRaft();
        }
        if (type == Robot.RobotType.chaos2019) {
            setup2019();
        }
        if (type == Robot.RobotType.chaos2020) {
            setup2020();
        }
        if (type == Robot.RobotType.simulator) {
            setupSimulator();
        }        

        addChild("LeftDrive", leftDrive);
        addChild("RightDrive", rightDrive);
        differentialDrive1 = new DifferentialDrive(leftDrive, rightDrive);
        addChild("Differential Drive 1", differentialDrive1);
        differentialDrive1.setSafetyEnabled(true);
        differentialDrive1.setExpiration(0.1);
        differentialDrive1.setMaxOutput(1.0);
    }

    private void setupRaft() {
        left1 = new Victor(RobotConstantsRaft.DRIVE_LEFT_VICTOR_A);
        addChild("Left1", left1);
        left1.setInverted(false);

        left2 = new Victor(RobotConstantsRaft.DRIVE_LEFT_VICTOR_B);
        addChild("Left2", left2);
        left2.setInverted(false);

        left3 = new Victor(RobotConstantsRaft.DRIVE_LEFT_VICTOR_C);
        addChild("Left3", left3);
        left3.setInverted(false);

        left4 = new WPI_TalonSRX(RobotConstantsRaft.DRIVE_LEFT_TALONSRX);
        addChild("Left4", left4);
        left4.setInverted(false);

        right1 = new Victor(RobotConstantsRaft.DRIVE_RIGHT_VICTOR_A);
        addChild("Right1", right1);
        right1.setInverted(false);

        right2 = new Victor(RobotConstantsRaft.DRIVE_RIGHT_VICTOR_B);
        addChild("Right2", right2);
        right2.setInverted(false);

        right3 = new Victor(RobotConstantsRaft.DRIVE_RIGHT_VICTOR_C);
        addChild("Right3", right3);
        right3.setInverted(false);

        right4 = new WPI_TalonSRX(RobotConstantsRaft.DRIVE_RIGHT_TALONSRX);
        addChild("Right4", right4);
        right4.setInverted(false);

        leftDrive = new SpeedControllerGroup(left1, left2, left3, left4);
        rightDrive = new SpeedControllerGroup(right1, right2, right3, right4);
    }

    private void setup2019() {
        leftSpark1 = new CANSparkMax(RobotConstants2019.DRIVE_LEFT_SPARKMAX_A, CANSparkMax.MotorType.kBrushless);
        // addChild("Left1", leftSpark1);
        leftSpark1.setInverted(false);

        leftSpark2 = new CANSparkMax(RobotConstants2019.DRIVE_LEFT_SPARKMAX_B, CANSparkMax.MotorType.kBrushless);
        // addChild("Left2", leftSpark2);
        leftSpark2.setInverted(false);

        rightSpark1 = new CANSparkMax(RobotConstants2019.DRIVE_RIGHT_SPARKMAX_A, CANSparkMax.MotorType.kBrushless);
        // addChild("Right1", rightSpark1);
        rightSpark1.setInverted(false);

        rightSpark2 = new CANSparkMax(RobotConstants2019.DRIVE_RIGHT_SPARKMAX_B, CANSparkMax.MotorType.kBrushless);
        // addChild("Right2", rightSpark2);
        rightSpark2.setInverted(false);

        leftDrive = new SpeedControllerGroup(leftSpark1, leftSpark2);
        rightDrive = new SpeedControllerGroup(rightSpark1, rightSpark2);
    }

    private void setup2020() {
        leftSpark1 = new CANSparkMax(RobotConstants2020.DRIVE_LEFT_SPARKMAX_A, CANSparkMax.MotorType.kBrushless);
        // addChild("Left1", leftSpark1);
        leftSpark1.setInverted(false);

        leftSpark2 = new CANSparkMax(RobotConstants2020.DRIVE_LEFT_SPARKMAX_B, CANSparkMax.MotorType.kBrushless);
        // addChild("Left2", leftSpark2);
        leftSpark2.setInverted(false);

        rightSpark1 = new CANSparkMax(RobotConstants2020.DRIVE_RIGHT_SPARKMAX_A, CANSparkMax.MotorType.kBrushless);
        // addChild("Right1", rightSpark1);
        rightSpark1.setInverted(false);

        rightSpark2 = new CANSparkMax(RobotConstants2020.DRIVE_RIGHT_SPARKMAX_B, CANSparkMax.MotorType.kBrushless);
        // addChild("Right2", rightSpark2);
        rightSpark2.setInverted(false);

        leftDrive = new SpeedControllerGroup(leftSpark1, leftSpark2);
		rightDrive = new SpeedControllerGroup(rightSpark1, rightSpark2);
    }

    private void setupSimulator() {
        left1 = new Victor(1);
        addChild("Left1", left1);
        left1.setInverted(false);

        right1 = new Victor(2);
        addChild("Right1", right1);
        right1.setInverted(false);

        sim_encoder_l = new Encoder(1, 2);
        sim_encoder_r = new Encoder(3, 4);

        leftDrive = new SpeedControllerGroup(left1);
        rightDrive = new SpeedControllerGroup(right1);
    }    

    private double encoderInches(WPI_TalonSRX driveInput) {
        if (driveInput == null) {
            return 0;
        }
        double wheelDiameter = 4.0;
        double gearRatio = (double) 1 / 1; // ratio of the axel the wheel lies on to the axel the encoder reads
        int ticksPerRev = 4096; // amount of ticks in one revolution of the encoder axel
        double counts = driveInput.getSensorCollection().getQuadraturePosition();
        double ratio = (gearRatio * wheelDiameter * Math.PI) / ticksPerRev;
        return counts * ratio;
    }

    private double encoderInches(CANSparkMax driveInput) {
        if (driveInput == null) {
            return 0;
        }
        double wheelDiameter = 4.0;
        double gearRatio = (double) 1 / 1; // ratio of the axel the wheel lies on to the axel the encoder reads
        if (type == Robot.RobotType.chaos2019)
        {
            wheelDiameter = 4.0;
            gearRatio = (double) 60 / 8.62;
        }
        if (type == Robot.RobotType.chaos2020)
        {
            wheelDiameter = 4.0;
            gearRatio = (double) 1 / 1;
        }
        int ticksPerRev = 42; // amount of ticks in one revolution of the encoder axel
        double counts = driveInput.getEncoder().getPosition();
        double ratio = (gearRatio * wheelDiameter * Math.PI) / ticksPerRev;
        return counts * ratio;
    }

    public double angleToDist(double angle) {
        double inchPerRev = 92.45; // constant equal to the total distance the wheels move for one full revolution
        return (inchPerRev * angle) / 360;
    }


    public void reportPosition() {

    }

    public double getRightPosition() {
        if (type == Robot.RobotType.raft) {
            return encoderInches(right4);
        }
        if (type == Robot.RobotType.chaos2019) {
            return -encoderInches(rightSpark1);
        }
        if (type == Robot.RobotType.chaos2020) {
            return encoderInches(rightSpark1);
        }
        if (type == Robot.RobotType.simulator) {
            return sim_encoder_r.get();
        }                 
        return 0;
    }

    public double getLeftPosition() {
        if (type == Robot.RobotType.raft) {
            return -encoderInches(left4);
        }
        if (type == Robot.RobotType.chaos2019) {
            return encoderInches(leftSpark1); // inverted for consistency with robot direction
        }
        if (type == Robot.RobotType.chaos2020) {
            return -encoderInches(leftSpark1);
        } 
        if (type == Robot.RobotType.simulator) {
            return sim_encoder_l.get();
        }         
        return 0;
    }

    public void PIDDrive() {
        double maxSpeed = 0.7;
        double minSpeed = 0.3;
        double right = PIDRight.calculate(getRightPosition());
        double left = PIDLeft.calculate(getLeftPosition());
        double leftSign = left / Math.abs(left);
        double rightSign = right / Math.abs(right);

        right = Math.min(maxSpeed, Math.max(minSpeed, Math.abs(right))) * rightSign;
        left = Math.min(maxSpeed, Math.max(minSpeed, Math.abs(left))) * leftSign;

        right = isAtRightTarget() ? 0 : right;
        left = isAtLeftTarget() ? 0 : left;

        differentialDrive1.tankDrive(left, right);

    }

    public void setTarget(double left, double right) {
        setpointLeft = left;
        setpointRight = right;
        PIDLeft.setSetpoint(left);
        PIDRight.setSetpoint(right);
    }

    public void setTargetAngle(double targetAngle) {
        double delta = angleToDist(targetAngle);
        double targetLeft = getLeftPosition() + delta;
        double targetRight = getRightPosition() - delta;
        Robot.driveBase.setTarget(targetLeft, targetRight);
        System.out.println("setTargetAngle initialized, target left = " + targetLeft + " target right = " + targetRight);
    }

    public boolean isAtTarget() {
        return isAtLeftTarget() && isAtRightTarget();
    }

    public boolean isAtRightTarget() {
        double error = 2;
        return (setpointRight < Robot.driveBase.getRightPosition() + error) && (setpointRight > Robot.driveBase.getRightPosition() - error);
    }

    public boolean isAtLeftTarget() {
        double error = 2;
        return (setpointLeft < Robot.driveBase.getLeftPosition() + error) && (setpointLeft > Robot.driveBase.getLeftPosition() - error);
    }

    @Override
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        setDefaultCommand(new TankDrive());
    }

    @Override
    public void periodic() {
        //SmartDashboard.putNumber("Right Encoder", right4.getSensorCollection().getQuadraturePosition());
        //SmartDashboard.putNumber("Left Encoder", -left4.getSensorCollection().getQuadraturePosition());
        // Put code here to be run every loop
        double rightInches = getRightPosition();
        double leftInches = getLeftPosition();
        // converts raw encoder readout to inches
        SmartDashboard.putNumber("Right Position", rightInches);
        SmartDashboard.putNumber("Left Position", leftInches);
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}
